#include "instanceitem.h"

#include <QPen>
#include <QDebug>
#include <QtGui>
#include <QRectF>
#include <QPainterPath>
#include <QGraphicsSceneMouseEvent>
#include "instanceline.h"

int InstanceItem::default_y = 0;
int InstanceItem::default_x = 0;
int InstanceItem::default_length = 500;
int InstanceItem::default_width = 80;
int InstanceItem::distance = 100;

void InstanceItem::MoveMessages(int amount)
{
    for (auto rect : rectangles){
        if ( rect->origin != nullptr){ //moving sender message
            const QLineF& line = rect->origin->line();
            if (rect->origin->IsLeftToRight()){
                if (line.p1().x() > line.p2().x() + amount){
                    rect->origin->setLine(line.x1() - Rectangle::width, line.y1(), line.x2() + amount, line.y1());
                }
                else {
                    rect->origin->setLine(line.x1(), line.y1(), line.x2() + amount, line.y1());
                }
                rect->origin->update();
            }
            else {
                if (line.p2().x() > line.p1().x() + amount){
                    rect->origin->setLine(line.x1() + Rectangle::width, line.y1(), line.x2() + amount, line.y1());
                }
                else {
                    rect->origin->setLine(line.x1(), line.y1(), line.x2() + amount, line.y1());
                }
            }
        }

        //moving sent messages


    }
}

void InstanceItem::MoveIfObstructed(int direction){
    bool moved = true;
    while (moved) {
        moved = false;
        //moving objects

        auto coliders = collidingItems();
        for (auto colider : coliders){
            if (dynamic_cast<InstanceItem*>(colider)){
                setPos(pos() + QPointF(direction*distance,0));
                MoveMessages(direction*distance);
                moved = true;
                break;
            }
        }
    }
}

InstanceItem::InstanceItem(QGraphicsItem *parent, int ID_class, QString text) :
    QGraphicsItem(parent), ID_class(ID_class), text(text), length(default_length), width(default_width)
{
    setFlag(QGraphicsItem::ItemIsSelectable);
    setFlag(QGraphicsItem::ItemIsFocusable);

    //setHandlesChildEvents(false);
}

void InstanceItem::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget) {
    //;painter->setBrush(Qt::black);
    painter->setPen(QPen(Qt::black, 3));
    QFont font = painter->font();

    font.setPointSize(font.pointSize() * 1.3);

    /* set the modified font to the painter */
    painter->setFont(font);

    painter->drawLine(default_x, default_y+70, default_x + width, default_y+70);

    painter->drawLine(default_x+ width /2, default_y + 70, default_x + width / 2, default_y + length);
    painter->drawText(QRectF(default_x, default_y, width, 60),Qt::AlignCenter, text);
}

QRectF InstanceItem::boundingRect() const {
     return QRectF(default_x, default_y, width, length);
}

void InstanceItem::keyPressEvent(QKeyEvent *event){
    switch (event->key()){
    case Qt::Key_Right:
        setPos(pos() + QPointF(distance,0));
        MoveMessages(distance);
        MoveIfObstructed(1);
        break;

    case Qt::Key_Left:
        setPos(pos() + QPointF(-distance,0));
        MoveMessages(-distance);
        MoveIfObstructed(-1);
        break;
    }

    QGraphicsItem::keyPressEvent(event);
}


void InstanceItem::mousePressEvent(QGraphicsSceneMouseEvent *event)
{
    QGraphicsItem::mousePressEvent(event);
}





